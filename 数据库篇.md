# 数据库篇

# 基础篇

## 1.数据发展过程：

- 文件操作

  ```python
  """
  小飞----123---18
  中飞-456-19
  大飞|789|20
  """
  ```

- 软件开发目录规范

  ```python
  """
  流星蝴蝶剑
  
  - config
  - core
  - lib
  - log
  - bin
  - db
  readme.md
  """
  ```

- 数据库程序

  关系型数据库：

  Mysql、Oracle、SQL server、DB2、Access

  - 数据之间有关系或约束

  - 数据通常以表格的形式储存

    | name（str） | pwd  | age（int） |
    | ----------- | ---- | ---------- |
    | xiaofei     | 123  | 18         |
    | xiaoming    | 258  | 19         |
    | xiaojun     | 368  | 20         |

  非关系型数据库：

  MongoDB、Redis、Memcache

  - 存储数据通常都是key、value的形式
  
    

## 2.Mysql引入

> mysql就是一款基于网络通信的应用程序，底层一定是用的socket

mysql服务端支持自己的客户端操作数据、也支持其他编程语言，**怎么解决语言不通的问题？**

- 让服务端精通所有编程语言
- 统一语言（sql语句）



## 3.MySQL安装

参考mysql安装文档：https://active.clewm.net/FrcyFA



## 4.SQL语句初体验

```sql
-- 启动和连接数据库
net start mysql -- 启动数据库服务(需要管理员权限)
net stop mysql -- 关闭数据库服务(需要管理员权限)
mysql -u root -p -- 连接到数据库

-- 每一条sql语句都是以分号结尾的

-- 库 --> 文件夹
-- 表 --> 文件
-- 记录 --> 文件里面的一行行数据
-- 杠杠是单行注释
/*
多行注释
*/

show databases; --查看所有数据库
\s -- 查看数据库字符编码以及其他信息的
\c -- 结束当前语句，或者用ctrl+c
exit; -- 退出连接
quit; -- 退出连接
help <命令> -- 查看命令的帮助信息
```

* 操作库

```sql
-- 增（create）
create database db1;
create database db1 charset=utf8;  -- 推荐
-- 删（drop）
drop database db2; -- 删除库
-- 改（alter）
alter database db2 charset=utf8; -- 改数据库的字符编码(当前mysql5.1版本之后只能改数据库的字符编码，不能改数据库名称了)
-- 查（show、describe(desc)）
show databases; -- 查所有数据库
show create database db1; -- 查一个，查看创建这个数据库的sql语句
```

* 操作表

```sql
select database(); -- 查看当前所在数据库
use db1; -- 切换数据库
-- 增（create）
create table movies(id int,name char); -- 创建表（默认字符编码，就是库的字符编码）
create table movies(id int,name char) charset=utf8; -- 创建表
-- 删（drop）
drop table movies; -- 删除当前库中的表
-- 改（alter）
alter table movies rename to MOVIES; -- 修改表名
alter table movies modify name char(4); -- 修改表字段类型
alter table movies change name NAME char(5); -- 修改表字段和类型
-- 查（show、describe(desc)）
show tables; -- 查看当前库下所有的表
show create table movies; -- 查看创建这个数据表的sql语句
describe movies; -- 查看一张表的结构，简写：desc movies;

-- 所有对表的操作都可以使用绝对路径的方式，这样即便不操作数据库，也可操作对应数据库的表
create table db.movies(id int,name char(4)) charset=utf8; -- 在指定的库中创建表
drop table db.movies; -- 删除指定库中的表
alter table db.movies change name NAME char(16); -- 修改指定库中表字段和类型
show create table db.movies; -- 查看指定库中的数据库表的sql语句
describe db.movies; -- 查看指定库的一张表的结构，简写：desc db.movies;

```

* 操作记录

```sql
-- 增 (insert into <表名> values())
insert into movies values(1,'流浪地球'); -- 插入一条记录
insert into movies values(1,'流浪地球'),(2,'三体'); -- 插入多条记录
-- 删 (delete from <表名> where)
delete from movies where name='三体';
-- 改 (update xx set)
update movies set name='满江红' where id=1;
-- 查 (select <字段> from <表名>)
select * from db1.movies; -- 查一个表的所有数据
select id,name from db1.movies; -- 查询这张表所有数据的id,name字段
select user,host from mysql.user; -- 查看user表里面所有用户的user字段和host字段
```

## 5.SQl语句分类

| 类型 | 描述                                           | 关键字                       |
| ---- | ---------------------------------------------- | ---------------------------- |
| DDL  | 数据库定义语言，用来定义和管理数据库或者数据表 | create,alter,drop            |
| DML  | 数据操纵语言，用来操作数据                     | insert,update,delete         |
| DQL  | 数据库查询语言，用来查询数据库                 | select                       |
| DCL  | 数据库控制语言，权限控制                       | grant,revoke,commit,rollback |

## 6.库的操作

> 参考之前的笔记

```sql
-- 增（create）
create database [if not exists] <库名> [charset=utf8];
create database [if not exists] <库名> [default charset utf8];
create database [if not exists] <库名> [default character set utf8mb4] [default collate 排序规则];
-- 删（drop）
drop database [if not exists] <库名>;
-- 改（alter）
alter database <库名> [charset=utf8];
-- 查（show、describe(desc)）
show databases;
show create database <库名>;
```

## 7.表操作

### **存储引擎**

> 表的类型，就是存储引擎

```sql
show engines; -- 查看所有的存储引擎

'InnoDB':支持事务、行级锁定和外键
'MRG_MYISAM':相同的MyISAM表的集合
'MEMORY':基于哈希，存储在内存中，适用于临时表
'BLACKHOLE':/dev/null存储引擎（您写入其中的任何内容都会消失）
'MyISAM':MyISAM存储引擎
'CSV': CSV存储引擎
'ARCHIVE':归档存储引擎
'PERFORMANCE_SCHEMA': 性能模式
'FEDERATED':联合MySQL存储引擎

Create table t1(id int,name char)engine=innodb;
Create table t2(id int,name char)engine=myisam;
Create table t3(id int,name char)engine=memory;
Create table t4(id int,name char)engine=blackhole;

insert into t1 values(1,'a');
insert into t2 values(1,'a');
insert into t3 values(1,'a');
insert into t4 values(1,'a');
```

### 创建表的语法

```sql
create table <表名>(
    <字段名1><字段类型>[(宽度)] [约束条件],
    <字段名2><字段类型>[(宽度)] [约束条件],
    <字段名3><字段类型>[(宽度)] [约束条件],
    <字段名4><字段类型>[(宽度)] [约束条件1,约束条件2]
)engine=innodb charset=utf8;
-- 宽度指的是字符个数，或者说字符串长度，关闭严格模式之后，即便宽度超了，也可以插进去（截取字符），5.6版本之后默认开启严格模式

-- 约束条件,注意顺序
[unsigned][zerofill][not null]
-- unsigned 无符号
-- zerofill 0填充
-- not null 非空
```

### 修改表的语法

```sql
-- 修改存储引擎
alter table <表名> engine=<存储引擎名称>;

-- 修改表名
alter table <表名> rename to <新表名>;

-- 增加字段
alter table <表名> add <字段名> <字段类型>[(宽度)] [约束条件] [first|after <字段名>];

-- 删除字段
alter table <表名> drop <字段名>;

-- 修改字段
alter table <表名> modify <字段名> <新字段类型>[(宽度)] [约束条件]; -- 修改表字段类型
alter table <表名> change <旧字段名> <新字段名> <新字段类型>[(宽度)] [约束条件]; -- 修改表字段类型和名称
```

### 删除和复制表语法

```sql
-- 删除表
drop table <表名>;

-- 复制创建表
create table <新表名> select * from <旧表名> [条件];

-- 复制创建表结构
create table <新表名> like <旧表名>;

```

## 8.数据类型

- 数值

  - int(整形)

  -- 整形创建的时候设置的宽度是其实是显示宽度，所以在创建时候无需对其设置宽度（这里指的是数据大小），只有以下几种大小，用unsigned约束条件设置为无符号范围，不设置约束条件时默认为有符号范围

  | 类型      | 大小   | 范围（有符号）                              | 范围（无符号）           | 描述       |
  | --------- | ------ | ------------------------------------------- | ------------------------ | :--------- |
  | tinyint   | 1Bytes | (-128，127)                                 | (0,255)                  | 很小的整数 |
  | smallint  | 2Bytes | (-32768，32767)                             | (0,65535)                | 较小的整数 |
  | mediumint | 3Bytes | (-8388608，8388607)                         | (0,16777215)             | 一般的整数 |
  | int       | 4Bytes | (-2147483648，2147483647)                   | (0,4294967295)           | 标准的整数 |
  | bigint    | 8Bytes | (-9223372036854775808，9223372036854775807) | (0,18446744073709551615) | 极大的整数 |

  - float

    ==乘二取整==

    3.625

    3 -> 11

    0.625 -> 0.625x2 = ==1==.25  0.25x2 = ==0==.5  0.5x2 = ==1==   -> 0.101

    3.625 -> 11.101

    > 浮点数的表现形式：==符号.尾数==.基数.==指数==
    >
    > ±m*2^e^ 
    >
    > 单精度浮点数（32位）：符号（1位）+指数（8位）+尾数（23位）
    >
    > 双精度浮点数（64位）：符号（1位）+指数（11位）+尾数（52位）

    符号：1 -> 负，0 -> 正或0

    指数：

    ​		10000001 -> 129 -> 2

    ​		10000000 -> 128 -> 1

    ​		01111111 -> 127-> 0

    ​		01111110 -> 126 -> -1

    ​		01111101 -> 125 -> -2

    尾数：把小数点前的二进制数，固定为1的规则

    ​		3.625 x 2^-1^ -> 3.625 x 0.5 = 1.8125

    ​		11.101 -> 1.11010000000000000000000		尾数：==11010000000000000000000==

    ​		1.8125 x 2^1^ = 3.625		指数：==^1^== -> 127+1=128 -> ==10000000==

    3.625 -> 11.101的存储方式：0 10000000 11010000000000000000000

    1.1101 -> 1 * 2^0^ + 1 * 2^-1^ + 1 * 2^-2^ + 0 * 2^-3^ + 1 * 2^-4^ = 1 + 0.5 + 0.25 + 0 + 0.0625 = 1.8125 * 2^1^ = 3.625

    3.1

    3 -> 11

    0.1 -> 0.1x2 = 0.2 0.2x2 = 0.4 0.4x2 = 0.8 0.8x2 = 1.6 0.6x2 = 1.2

    3.1 -> 11.0 0011 0011 0011 0011.......

    精度问题：如果小数最后一位不是5的话，不精确，延长循环让精度更高

    无法保存极小的小数：最小非零值

  | 类型    | 大小（m表示所有位数，d表示小数位数）   | 范围（有符号）                                               | 范围（无符号）                                               | 描述            |
  | :------ | :------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
  | float   | 4 Bytes float(m, d) m最多255，d最多30  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
  | double  | 8 Bytes double(m, d) m最多255，d最多30 | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
  | decimal | decimal(m,d) m最大65，d最大30          | 依赖于m和d的值                                               | 依赖于m和d的值                                               | 小数值          |

- 字符

  - char（定长字符串）

    > char(10) 最多能存10个字符，如果超过10个字符，会直接报错，如果不足10个字符，空格补齐(会补充在数据尾部，但查询的时候会自动把尾部的空格去掉，所以当尾部数据有空格时，不要用char)
    >
    > 缺点：浪费空间
    >
    > 优点：存取速度快
    >
    > 范围：0-255字符

  - varchar（变长字符串）

    > varchar(10) 最多能存10个字符，如果超过10个字符，会直接报错，如果不足10个字符，直接存
    >
    > 优点：节省空间
    >
    > 缺点：存取速度慢    头hello头fei头heiheihei
    >
    > 范围：0-65535字节，一行的最大字节数。（注：数据库一行数据的最大字节不可超过65535）
    >
    > 最大字符数 = （65535-行其它字段总字节数-null标志字节数-长度标志字节数）/ 字符集单字符最大字节数。（注：utf8字符集一个字符占三个字节，gbk字符集一个字符占三个字节）
- 时间日期

  - year(年)
  - date(日期：年-月-日)

  - time(时间：时-分-秒)

  - datetime(日期时间：年-月-日 时-分-秒)

    > 8字节，1000～9999

  - timestamp

    > 4字节，1970～2038
    
    ```sql
    create table user(
    	id int,
    	name varchar(16),
    	born year,
    	brith date,
    	active time,
    	reg_time datetime);
    insert into user values(1,'fei',now(),now(),now(),now());
    insert into user values(2,'jack','2025','2025-10-10','12:00:00','2025-10-10 12:00:00');
    
    ```
    
  
- 枚举

> enum：单选

```sql
create table t14(
	id int,
	name varchar(16),
	gender enum('male','female','other')
	);
insert into t14 values(1,'fei','male');
-- 注：只能在给定的范围内插入一条
```



- 集合

> set：多选

```sql
create table t15(
	id int,
	name varchar(16),
	hobby set('tea','cola','beer')
	);
insert into t15 values(1,'fei','tea');
insert into t15 values(1,'fei','tea,cola');
-- 注：可在给定的范围内插入多条，用逗号隔开
```

## 9.约束条件

-- 约束条件,注意顺序([unsigned] [zerfill]放前面)
-- unsigned zerofill not null default unique 

- unsigned 无符号
- zerfill 0填充
- not null 非空
- default <value> 设置默认值
- unique 唯一

```sql
create table t16(id int unsigned zerofill not null);-- unsigned、zerofill属于类型约束，not null属于字段约束，所以约束条件需要先写类型约束后写字段约束
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id    | int(10) unsigned zerofill | NO   |     | NULL    |       |

-- 单列唯一:一个字段单独唯一
create table user(id int unique, name vachar(16) unique);

create table user(id int, name vachar(16),
                 unique(id),
                 unique(name)); -- 可把unique写在字段类型后，或者写为unique(字段名称)
-- 联合唯一：多个字段一起唯一
create table app(id int,
                host varchar(15),
                port int,
                unique(host,port),
                unique(id));
                
insert into app values
(1,'192.168.3.1',3306),
(2,'192.168.3.2',9000),
(3,'192.168.3.2',3306);

insert into app values
(4,'192.168.3.1',3306);

```

- primary key 主键（约束特性：不为空，且唯一）

```sql
-- 单列主键
create table t19(
	id int primary key,
	name varchar(16));
	
insert into t19 values(1,'fei'),(2,'jack');
insert into t19 values(1,'rose'); -- 插入相同的id报错
insert into t19(name) values('rose'); -- 插入空id报错

-- 创建表时不指定主键的话，会默认把唯一且不为空的字段指定为组件
create table t20(
	name varchar(16),
	age int unique not null);
	
-- 复合主键
create table app1(id int,
                host varchar(15),
                port int,
                primary key(host,port),
                unique(id));
                
insert into app1 values
(1,'192.168.3.1',3306),
(2,'192.168.3.2',9000),
(3,'192.168.3.2',3306);

insert into app values
(4,'192.168.3.1',3306);
```

- auto_increment：自动递增

```sql
create table db4;
use db4;
create table t1(id int primary key auto_increment,
                name varchar(16)
               );
               
insert into t1(name) values('fei'),('jack'),('rose');-- 无需传id，自动递增（会在最后插入的id基础上递增）

-- 清空表(删除表数据)
delete from t1; -- 清空所有数据，不清空自增值
delete from t1 where id=1; -- 删除id为1的数据
truncate t1; -- 清空所有数据，并且清空自增值

```

- foreign key：外键约束

```sql
create table dep(
	id int primary key,
    name varchar(16),
    `desc` varchar(64)
);

create table emp(
	id int primary key,
    name varchar(16),
    gender enum('male','female'),
    mobile varchar(11),
    dep_id int,
    foreign key(dep_id) references dep(id)
    on delete cascade
    on update cascade
); -- 把emp表的dep_id字段关联到dep表的id字段
-- on delete cascade on update cascade的作用：删除与更新同步，使得存在外键的表不需要去改或者删除外键表的数据，可之间修改本数据表。当本数据表中引用的外键数据没有了时自动删除外键表中的该条数据，当本数据表中的外键数据更新时自动更新外键表

insert into dep values(1,'研发部','造火箭的'),(2,'销售部','卖火箭的'),(3,'人事部','裁员的');
insert into emp values(1,'fei','male','131',1),
	(2,'大仙','male','137',2),
	(3,'tom','male','138',2),
	(4,'jack','male','135',3),
	(5,'rose','female','139',3);

delete from emp where dep_id=1;
delete from dep where id=1;

update dep set name = '市场部' where id=2;
update dep set id = 999 where id=2;

-- 大型项目不建议用外键，小型项目可用
```

## 10.关系

- 多对一或一对多

```sql
create table dep(
	id int primary key,
    name varchar(16),
    `desc` varchar(64)
);

create table emp(
	id int primary key,
    name varchar(16),
    gender enum('male','female'),
    mobile varchar(11),
    dep_id int,
    foreign key(dep_id) references dep(id)
    on delete cascade
    on update cascade
);

insert into dep values(1,'研发部','造火箭的'),(2,'销售部','卖火箭的'),(3,'人事部','裁员的');
insert into emp values(1,'fei','male','131',1),
	(2,'大仙','male','137',2),
	(3,'tom','male','138',2),
	(4,'jack','male','135',3),
	(5,'rose','female','139',3);
```

- 多对多

```sql
create table song(
	id int primary key auto_increment,
    name varchar(16) not null
);
create table singer(
	id int primary key auto_increment,
    name varchar(16) not null
);
create table song2singer(
	id int primary key auto_increment,
    singer_id int not null,
    song_id int not null,
    foreign key(singer_id) references singer(id) on delete cascade on update cascade,
    foreign key(song_id) references song(id) on delete cascade on update cascade
); -- 这张表是用来建立上面两张表的多对多关系的，即将两张表的外键都建立在另外一张表内

insert into song(name) values
('以父之名'),
('夜的第七章'),
('止战之殇'),
('夜曲'),
('北京欢迎你');
insert into singer(name) values
('周杰伦'),
('刘欢'),
('韩红'),
('成龙');
insert into song2singer(singer_id, song_id) values
(1,1),
(1,2),
(1,3),
(1,4),
(2,5),
(3,5),
(4,5);
```

- 一对一

```sql
create table customer(
	id int primary key,
    name varchar(16),
    gender enum('male', 'female'),
    mobile varchar(11),
);

create table owner(
	id int primary key,
    room_number varchar(16),
    area int,
    is_loan enum(true,false),
    customer_id int unique,
    foreign key(customer_id) references customer(id) on delete cascade on update cascade
); -- 保证customer_id的唯一性即可保证数据表的一对一性质


insert into customer values
(1, 'fei', 'male', '131'),
(2, '大仙', 'female', '150'),
(3, 'tom', 'female', '139'),
(4, 'jack', 'male', '135'),
(5, 'rose', 'male', '137');

insert into owner values
(1, '688', 300, false, 2),
(1, '233', 180, true, 4);
```

## 11.记录的查询语法

```sql
select distinct <字段....> from <库名>.<表名> 
	where <条件> 
	group by <分组条件>
	having <过滤条件>
	order by <排序字段> {ASC | DESC} -- 默认升序ASC
	limit n;
```

例子

```sql
create database db5;
use db5;
create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    age int not null,
    salary float(10, 2),
    dep varchar(32),
    notes varchar(64)
);

insert into emp(name, gender, age, salary, dep) values
('关羽', 'male', 20, 8000, '技术部'),
('张飞', 'male', 25, 12000, '技术部'),
('赵云', 'male', 19, 6800, '技术部'),
('马超', 'male', 26, 11000, '技术部'),
('黄忠', 'female', 48, 15000, '技术部'),
('夏侯惇', 'male', 36, 34000, '技术部'),
('典韦', 'male', 19, 6500, '技术部'),
('吕布', 'female', 20, 9000, '技术部'),
('周瑜', 'female',32, 36000, '技术部'),
('文丑', 'male', 27, 24000, '技术部'),

('刘备', 'male', 32, 4000, '市场部'),
('诸葛亮', 'male', 27, 2700, '市场部'),
('庞统', 'male', 37, 4200, '市场部'),
('徐庶', 'male', 36, 4000, '市场部'),
('荀彧', 'male', 25, 2400, '市场部'),
('荀攸', 'male', 25, 2400, '市场部'),
('鲁肃', 'male', 43, 4300, '市场部'),
('司马懿', 'female', 44, 5000, '市场部'),
('杨修', 'male', 19, 800, '市场部'),
('丁仪', 'male', 49, 3500, '市场部'),

('宋江', 'male', 30, 4000, '人事部'),
('吴用', 'male', 38, 3000, '人事部'),
('扈三娘', 'female', 42, 2500, '人事部'),
('顾大嫂', 'female', 38, 3300, '人事部'),
('孙二娘', 'female', 32, 2400, '人事部'),
('丁得孙', 'male', 32, 2800, '人事部'),


('柴进', 'male', 30, 4200, '财务部'),
('卢俊义', 'male', 44, 4000, '财务部');

-- 四则运算
select name,salary*12 years from emp;
select name,salary*12 as yearly_salary years from emp;
select name,salary*12 yearly_salary years from emp;

-- 设置显示格式
-- 姓名：关羽 年龄：20 薪资：8000
-- 姓名：张飞 年龄：25 薪资：12000
-- concat
select concat('姓名：',name, '  年龄：',age) as '姓名，年龄', concat('薪资：',salary) as '薪资' from emp;
select concat(name,'-',age,'-',salary) as '姓名-年龄-薪资' from emp;
-- concat_ws
select concat_ws('-',name,age,salary) as '姓名-年龄-薪资' from emp;
```

- where

```sql
select name,age from emp where age > 35;
select name,age,dep from emp where dep = '技术部' and age > 35;
-- 年龄大于等于30，小于等于40
select name,age from emp where age >= 30 and age <= 40;
select name,age from emp where age between 30 and 40; -- 闭区间，包含30和40，用between and

-- 年龄小于30，或者大于40
select name,age from emp where age<30 or age>40;
select name,age from emp where not age between 30 and 40; -- 对30到40之间取反就是小于30，或者大于40

-- 工资为3000，4000，5000的员工
select name,salary from emp where salary=3000 or salary=4000 or salary=5000;
select name,salary from emp where salary in (3000,4000,5000); -- in表示是否在此范围内

-- is null
select * from emp where notes=''; -- 空字符串不是null
select * from emp where notes is null; -- 查询是否为空字符串
select * from emp where notes is not null;

-- like模糊匹配
-- _表示正则里面的.
-- %表示正则里面的.*
select * from emp where name like '荀_'; -- 有几个下划线表示有几个字符
select * from emp where name like '丁__';
select * from emp where name like '丁%'; -- 百分号表示多个字符

-- 正则表达式
select * from emp where name regexp '^丁.*'; -- regexp后面跟正则表达式

-- 查询丁或者荀开头的名字
select * from emp where name regexp '^(丁|荀).*';
```

- group by

```sql
-- group by必须放在where后面
select dep from emp group by dep; -- 分组之后只能查分组的字段

-- 聚合函数
count
max
min
sum
avg

-- 统计每个部门的员工数量
select dep,count(id) as dep_count from emp group by dep;

-- 每组的年龄最大是多少
select dep,max(age) from emp group by dep;

-- 每组最低工资
select dep,min(salary) from emp group by dep;

-- 每组工资总和
select dep,sum(salary) from emp group by dep;

-- 每组平均工资
select dep,avg(salary) from emp group by dep;

-- 统计所有员工的平均工资
select avg(salary) from emp;

-- 查询每个部门所有员工名字
select dep, group_concat(name) from emp group by dep; -- group_concat用于对分组内容进行拼接

-- 统计每个部门年龄大于45的员工数量
select dep,count(id) from emp where age>45 group by dep;

-- 统计男员工和女员工的数量
select gender,count(id) from emp group by gender;

select gender g,count(id) as emp_count from emp group by g having emp_count>10; -- 别名用法举例
```

- having

```sql
-- 查询所有部门内，员工数量小于5的部门，以及该部门内的员工名字和员工数量
select dep,count(id),group_concat(name) from emp group by dep having count(id)<5;

-- 查询各部门年龄大于35的员工超过3个人的部门名，以及大于35的人数
select dep,count(id) from emp where age>35 group by dep having count(id)>3;
```

- order by

```sql
-- 对所有员工，按工资进行升序排列
select * from emp order by salary asc; -- asc可不写，因为默认就是asc升序

-- 对所有员工，按工资进行降序排列
select * from emp order by salary desc;

-- 对所有员工，按工资进行降序排列,工资相同的按id字段升序排列
select * from emp order by salary desc, id asc;
```

- limit

```sql
-- 只要展示五条数据
select * from emp limit 5;

-- 找出公司工资最高的5个人
select * from emp order by salary desc limit 5;

-- 分页
select * from emp limit 0,10; -- 从第0条开始取十条
select * from emp limit 10,10; -- 从第10条开始取十条
select * from emp limit 20,10; -- 从第20条开始取十条
```

## 12.函数

- 字符串处理函数

```sql
select concat('a', 'b', 'c'); 		-- 字符串拼接
select lower('HELLO'); 				-- 转小写
select upper('hello');				-- 转大写
select lpad('hello', 10, '-');		-- 左填充，用字符串"-"在"hello"的左边填充至10个字符，原字符串长度超过10，则会截取至10个字符
select rpad('hello', 10, '-');		-- 右填充，用字符串"-"在"hello"的右边填充至10个字符，原字符串长度超过10，则会截取至10个字符
select trim('   hello  ');			-- 去掉字符串两端的空格
select substring('hello',2,3); 		-- 字符串切片，从第2个字符开始，切3个字符
```

- 数值处理函数

```sql
select ceil(1.3);			-- 向上取整
select floor(1.6);			-- 向下取整
select mod(10,3);			-- 获取10/2的模
select rand();				-- 获取0～1的随机小数
select round(3.1415926,4);	-- 对3.1415926四舍五入，保留4位小数
```



- 日期处理函数

```sql
select '当前日期', curdate();					    -- 获取当前日期
select '当前时间', curtime();						-- 获取当前时间
select '当前日期时间', now();						-- 获取当前日期和时间
select '年', year('2023-10-08 18:36:59');		-- 获取date_time的年份
select '月', month('2023-10-08 18:36:59');		-- 获取date_time的月份
select '日', day('2023-10-08 18:36:59');			-- 获取date_time的日期
select '时', hour('2023-10-08 18:36:59');		-- 获取date_time的小时
select '分', minute('2023-10-08 18:36:59');		-- 获取date_time的分钟
select '秒', second('2023-10-08 18:36:59');		-- 获取date_time的秒

-- 时间差计算，interval单位:year,month,day,hour,minute,second, microsecond
select date_add(now(), interval 1 year); 					   -- 获取从now()开始,1年后的时间
select date_add('2023-10-08 18:36:59', interval 1 month); 	   -- 获取指定时间1月后的时间
select datediff('2025-10-08 18:36:59', now()); 				   -- 获取两个时间之间的天数，第一个值减去第二个值
select timediff('2023-10-08 18:36:59', '2023-10-08 12:00:00'); -- 获取两个时间之间的时间差值
```

- 流程控制函数

```sql
-- 单分支
select name, if(gender='male', '小哥哥', '小姐姐')as '性别' from emp; 	-- 如果性别等于male返回小哥哥，否则返回小姐姐
select ifnull(gender, '未知') from emp;				 -- 如果第一个值不为空，则返回第一个值，否则返回第二个值
select ifnull(notes, '没有任何内容哦') from emp;

-- 多分支
-- case..when..then..end
-- case <字段> when <条件1> then <条件1满足返回> when <条件2> then <条件2满足返回>...end
-- 工资大于10000：核心员工
-- 工资5000-10000：普通员工
-- 工资5000以下：新员工
select
	name,
	case when salary>10000 then '核心员工' when salary>5000 then '普通员工' else '新员工' end as '员工级别'
from emp;

-- 技术部：高级技术顾问
-- 人事部：HR
-- 其它：销售经理
select
	name,
    case dep when '技术部' then '高级技术顾问' when '人事部' then 'HR' else '销售经理' end as '职位'
from emp;
```

## 13.多表查询

```sql
create database db6;
use db6;
create table dep(
	id int primary key auto_increment,
    name varchar(16),
    notes varchar(64)
);
insert into dep(name) values
('总经办'),('技术部'),('市场部'),('人事部'),('财务部'),('后勤部');

create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    age int not null,
    salary float(10, 2),
    post varchar(16),
    join_date date,
    leader_id int,
    dep_id int
);

insert into emp values
(1, '刘备', 'male', 32, 4000, '总经理', '2035-06-01', null, 1),

(2, '关羽', 'male', 20, 8000, '技术总监', '2035-06-05', 1, 2),
(3, '张飞', 'male', 25, 12000, '项目经理', '2035-06-10', 2, 2),
(4, '赵云', 'male', 19, 6800, '产品经理', '2035-06-10', 2, 2),
(5, '马超', 'male', 26, 11000, '后端开发', '2035-07-11', 2, 2),
(6, '黄忠', 'female', 48, 15000, '后端开发', '2035-07-22', 2, 2),
(7, '夏侯惇', 'male', 36, 34000, '后端开发', '2035-07-29', 2, 2),
(8, '典韦', 'male', 19, 6800, '后端开发', '2035-08-02', 2, 2),
(9, '吕布', 'female', 20, 9000, '前端开发', '2035-08-03', 2, 2),
(10, '周瑜', 'female',32, 36000, '前端开发', '2035-08-08', 2,  2),
(11, '文丑', 'male', 27, 24000, '测试', '2035-08-12', 2, 2),

(12, '诸葛亮', 'male', 27, 8000, '市场总监', '2035-06-05', 1, 3),
(13, '庞统', 'male', 37, 4200, '销售', '2035-06-06', 12, 3),
(14, '徐庶', 'male', 36, 4000, '销售', '2035-06-12', 12, 3),
(15, '荀彧', 'male', 25, 2400, '销售', '2035-06-10', 12, 3),
(16, '荀攸', 'male', 25, 2400, '销售', '2035-06-12', 12, 3),
(17, '鲁肃', 'male', 43, 4300, '销售', '2035-06-18', 12, 3),
(18, '司马懿', 'female', 44, 5000, '销售', '2035-06-20', 12, 3),
(19, '杨修', 'male', 19, 800, '销售', '2035-07-10', 12,  3),
(20, '丁仪', 'male', 49, 3500, '销售', '2035-07-11', 12, 3),

(21, '宋江', 'male', 30, 8000, '人事总监', '2035-06-05', 1, 4),
(22, '吴用', 'male', 38, 3000, '人事主管', '2035-06-06', 21, 4),
(23, '扈三娘', 'female', 42, 2500, '招聘专员', '2035-06-11', 21, 4),
(24, '顾大嫂', 'female', 38, 3300, '招聘专员', '2035-06-25', 21, 4),
(25, '孙二娘', 'female', 32, 2400, '绩效专员', '2035-07-22', 21, 4),
(26, '丁得孙', 'male', 32, 2800, '培训专员', '2035-08-10', 21, 4),


(27, '柴进', 'male', 30, 8000, '财务总监', '2035-06-05', 1, 5),
(28, '卢俊义', 'male', 44, 4000, '会计', '2035-08-19', 27, 5),
(29, '晁盖', 'male', 44, 3500, '出纳', '2035-08-20', 27, 5),

(30, '貂蝉', 'female', 36, 800, null, '2035-09-01', null, null);
```

**笛卡尔积**

> a b c
>
> 1 2 3
>
> a1 a2 a3 b1 b2 b3 c1 c2 c3

- 连接查询

  - 内连接（取的是两张表的交集）

    - 隐式内连接

    ```sql
    select * from emp,dep where emp.dep_id=dep.id;
    ```

    - 显式内连接

    ```sql
    select <字段> from <表a> [inner]join <表b> on <条件>;
    
    select * from emp join dep on emp.dep_id=dep.id;
    ```

    

  - 外连接

    - 左外连接（取的是左表所有数据和交集部分）

      > 查询左表所有数据，包括交集部分

      ```sql
      select <字段> from <表a> left [outer] join <表b> on <条件>;
      
      -- 查询所有员工数据和部门信息
      select emp.name,dep.name from emp left join dep on emp.dep_id = dep.id;
      ```

      

    - 右外连接（取的是右表所有数据和交集部分）

      > 查询右表所有数据，包括交集部分

      ```sql
      select <字段> from <表a> right [outer] join <表b> on <条件>;
      
      -- 查询所有部门数据以及对应员工数据
      select dep.name,emp.name from emp right join dep on emp.dep_id = dep.id;
      ```

      

  - 自连接（是同一张表在连接）

    > select <字段> from <表a> <a> join <表b> <b> on <条件>;
    >
    > 可以用内连接、外连接

    ```sql
    -- 查询员工和对应的领导名字
    select a.name '员工',b.name '领导' from emp a join emp b on a.leader_id=b.id;
    -- 查询员工和对应的领导名字,包括没有领导的
    select a.name '员工',b.name '领导' from emp a left join emp b on a.leader_id=b.id;
    ```

  - 联合查询

    >把多次查询的结构合并在一起，但多条select的列数必须相同。关键字：union，union all
    >
    >select .... union [all] select ....;
    >
    >异同：使用union可去除重复数据，union all不行

    ```sql
    -- 查询薪资大于等于15000的员工，和部门表，以及年龄大于等于45的员工
    select * from emp where salary>=15000
    union
    select * from emp where age>45;
    
    -- 查询查询薪资大于等于15000的员工，和部门表
    select name,age,gender from emp where salary>=15000
    union
    select * from dep;
    ```

- 子查询

  > select之后，from之后，where之后

  - 标量子查询：子查询的结果是单个值

    > 操作符：比较运算符

    ```sql
    -- 查询技术部所有员工信息
        -- 1、查询技术部id
        select id from dep where name='技术部';
        -- 2、查询技术部所有员工信息
        select * from emp where dep_id=(select id from dep where name='技术部');
    
    -- 查询薪资比黄忠高的员工信息
        -- 1、查询黄忠的薪资
        select salary from emp where name='黄忠';
        -- 2、查询薪资比黄忠高的员工信息
        select * from emp where salary>(select salary from emp where name='黄忠');
    ```

    

  - 列子查询：子查询的结果是一列

    - in
    - not in
    - any ：子查询返回列表中，有任何一个满足即可
    - some ：同any
    - all ：子查询返回的列表的所有值，都必须满足

    ```sql
    -- 列子查询
    -- 查询人事部和财务部的所有员工
        -- 1、查询人事部和财务部id
        select id from dep where name in ('人事部','财务部');
        -- 2、根据id查询员工信息
        select * from emp where dep_id in (select id from dep where name in ('人事部','财务部'));
    
    -- 查询比市场部所有人入职都晚的员工信息
        -- 1、查询市场部的id
        select id from dep where name = '市场部';
        -- 2、查询市场部所有人的入职日期
        select join_date from emp where dep_id=(select id from dep where name = '市场部');
        -- 3、比市场部所有人入职都晚的员工信息
        select * from emp where join_date>all(select join_date from emp where dep_id=(select id from dep where name = '市场部'));
    
        select max(join_date) from emp where dep_id=(select id from dep where name = '市场部');
        select * from emp where join_date>(select max(join_date) from emp where dep_id=(select id from dep where name = '市场部'));
    ```
  
  - 行子查询：子查询的结果是一行
  
    > 操作符： =	!=	in	not in
  
    ```sql
    -- 行子查询
    -- 查询和关羽薪资相同，并且领导也相同的员工信息
        -- 1、查询关羽的薪资和领导id
        select salary,leader_id from emp where name='关羽';
        -- 2、查询其他员工信息
        select * from emp where (salary,leader_id)=(select salary,leader_id from emp where name='关羽');
        
    -- 查询和关羽薪资不相同，并且领导也不相同的员工信息
    select * from emp where (salary,leader_id)!=(select salary,leader_id from emp where name='关羽');
    
    -- in用法
    select * from emp where (salary,leader_id)in ((8000,1),(6800,2));
    
    -- not in用法
    select * from emp where (salary,leader_id)not in ((8000,1),(6800,2));
    ```
  
  - 表子查询：子查询的结果是多列
  
    > 操作符：in	not in
  
    ```sql
    -- 表子查询
    select salary,leader_id from emp where name = '关羽' or name = '赵云';
    select * from emp where (salary,leader_id)in (
    select salary,leader_id from emp where name = '关羽' or name = '赵云');
    
    -- 查询工资为八千的员工信息，以及部门信息
        -- 1、查询工资为八千的员工信息
        select * from emp where salary=8000;
        -- 2、 查询这部分员工的部门信息
        select e.*,d.name from (select * from emp where salary=8000) e left join dep d on e.dep_id=d.id;
    	-- 其他解法
        select emp.*,dep.name from emp left join dep on emp.dep_id = dep.id where emp.salary=8000;
    ```
  
    练习
    
    ```sql
    -- 职位等级表
    create table job_grade(
        id int primary key auto_increment,
        grade varchar(16),
        min_salary int,
        max_salary int
    );
    
    insert into job_grade(grade, min_salary, max_salary) values
    ('p1', 0, 4999),
    ('p2', 5000, 9999),
    ('p3', 10000, 14999),
    ('p4', 15000, 19999),
    ('p5', 20000, 29999),
    ('p6', 30000, 39999);
    
    -- 1、查询所有员工的职位等级
    -- 表：emp    job_grade
    -- 连接条件：emp.salary>=job_grade.min_salary and emp.salary<=job_grade.max_salary
    select emp.*, job_grade.grade from emp left join job_grade on emp.salary>=job_grade.min_salary and emp.salary<=job_grade.max_salary order by emp.id;
    select emp.name, emp.salary, job_grade.grade, job_grade.min_salary, job_grade.max_salary
    from emp
             left join job_grade on emp.salary between job_grade.min_salary and job_grade.max_salary
    order by emp.id;
    
    -- 2、查询人事部所有员工信息，以及他们的职级
    -- 表：emp    job_grade   dep
    -- 连接条件：emp.salary>=job_grade.min_salary and emp.salary<=job_grade.max_salary   emp.dep_id=dep.id
    -- 查询条件：dep.name = '人事部'
    select emp.*, dep.name,job_grade.grade
    from emp
             join job_grade on emp.salary >= job_grade.min_salary and emp.salary <= job_grade.max_salary
             join dep on emp.dep_id = dep.id
    where dep.name = '人事部';
    
    -- 3、查询薪资低于每个部门平均值的员工信息
        -- 查询每个部门的平均工资
        select avg(salary) from emp where dep_id=3;
        -- 查询薪资低于每个部门平均水平的员工信息
        select * from emp;
    select b.*, (select avg(a.salary) from emp a where a.dep_id = b.dep_id) 'avg_salary'
    from emp b
    where salary < (select avg(a.salary) from emp a where a.dep_id = b.dep_id);
    
    -- 4、查询每个部门的员工数量
        -- 查询某个部门人数
        select count(e.id) from emp e where e.dep_id=2;
        -- 查询部门id和name
        select id,name from dep;
        -- 结合起来
        select (select count(e.id) from emp e where e.dep_id=d.id) '人数',d.name from dep d;
        
    -- 多对多
    create table music(
        id int primary key auto_increment,
        name varchar(16)
    );
    insert into music(name) values
    ('以父之名'),('夜的第七章'),('止战之殇'),('夜曲'),('罗刹海市'),('北京欢迎你');
    
    create table singer(
        id int primary key auto_increment,
        name varchar(16)
    );
    insert into singer(name) values
    ('周杰伦'), ('刀郎'), ('刘欢'), ('韩红'), ('成龙');
    
    create table singer2music(
        id int primary key auto_increment,
        music_id int,
        singer_id int
    );
    insert into singer2music(music_id, singer_id) values
    (1, 1),(2, 1),(3, 1),(4, 1),(5, 2),(6, 3),(6, 4),(6, 5);
    
    -- 查询所有歌曲，以及对应的歌手
    -- 表：music  singer  singer2music
    -- 连接条件：music.id = singer2music.music_id    singer.id = singer2music.singer_id
    select m.name, s.name
    from music m
             join singer2music sm on m.id = sm.music_id
             join singer s on s.id = sm.singer_id;
    
    select m.name, s.name
    from music m,
         singer2music sm,
         singer s
    where m.id = sm.music_id
      and s.id = sm.singer_id;
    ```
    

## 14.数据库控制语言（DCL）

> 管理数据库的用户，控制数据库访问权限
>
> 用户a-> db1
>
> 用户b-> db1 db2

- 用户管理

  - 创建用户

    > create user '用户名'@'主机名' identified by '密码';

    ```sql
    -- 创建用户不需要切换到mysql库，会自动去查找mysql库
    create user 'fei'@'localhost' identified by '123'; -- localhost表示只能在本机登录
    create user 'fei'@'%' identified by '123'; -- 百分号表示可以在任意ip登录
    ```

  - 删除用户

    > drop user '用户名'@'主机名';

    ```sql
    drop user 'fei'@'localhost';
    ```

  - 修改用户

    > alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
    >
    > update mysql.user set host='主机名' where user='用户名';

    ```sql
    alter user 'fei'@'localhost' identified with mysql_native_password by '456'; -- 修改密码
    update mysql.user set host='主机名' where user='用户名'; -- 修改用户名
    ```

  - 查询用户

    > select * from mysql.user;

    ```sql
    select * from mysql.user;
    ```

- 权限控制（运维、DBA）

  - all/all privileges：所有权限
  - insert：插入数据权限
  - delete：删除数据权限
  - update：修改数据权限
  - select：查询数据权限
  - create：创建数据库/表权限
  - drop：删除数据库/表/视图权限
  - alter：修改表/字段权限

  查询用户权限

  > show grants for '用户名'@'主机名'；

  ```sql
  show grants for 'fei'@'localhost';
  show grants for 'root'@'localhost';
  ```

  分配权限

  > grant 权限列表 on 库名.表名 to '用户名'@'主机名';

  ```sql
  grant all on db6.* to 'fei'@'localhost';
  ```

  撤销权限

  > revoke 权限列表 on 库名.表名 from '用户名'@'主机名';

  ```sql
  revoke all on db6.* from 'fei'@'localhost';
  ```

  刷新权限

  > flush privileges;

  ```sql
  flush privileges;
  ```


## 15.事务

### 15.1事务概述

> 一组操作的集合（多条sql语句的集合），这个集合是一个不可分割的工作单位，它会把集合内的所有操作一起提交，如果提交过程中，有任何一条sql出现了错误，那便会回退到整个事务执行之前的状态，即：要么同时成功，要么同时失败

```sql
银行转账
李白 500
杜甫 1000
"""
开启事务
1.查询李白的余额
2.从李白的账户-100
异常 -> 回滚
3.给杜甫账户+100
提交事务
"""
```

>查看事务的提交方式：`select @@autocommit;`
>
>设置事务的提交方式：`set @@autocommit=0;` -- 设置事务手动提交，1为自动提交。仅对当前会话有效，重新连接数据库就不生效了
>
>开启事务：`start transaction;`  或者：`begin;`
>
>提交事务：`commit;`
>
>回滚事务：`rollback;`

```sql
-- 账户表
create table account(
    id int primary key auto_increment,
    name varchar(16),
    balance int
);

insert into account(name, balance) values
('李白', 500),
('杜甫', 1000);

select @@autocommit; -- 查询事务提交方式
set @@autocommit=1; -- 设置事务手动提交，1为自动提交

-- 以下两条都是开启事务，需要放在事务里的sql执行前执行。这两天不需要将自动提交事务关闭
start transaction; 
begin;

-- 1.查询李白的余额
    select * from account where name = '李白';
-- 2.从李白的账户-100
    update account set balance = balance-100 where name = '李白';
-- 异常 -> 回滚
   print('异常')
-- 3.给杜甫账户+100
    update account set balance = balance+100 where name = '杜甫';

-- 提交事务：执行完事务后，如果需要通过就执行commit提交到数据库
commit;

-- 回滚事务：执行完事务后，如果不通过就执行rollback回滚
rollback;

-- 注：执行完事务后都要执行commit或rollback来关闭此事务，不然执行其他sql语句会认为还在此事务中执行
```

### 15.2事务的四大特性

- 原子性(**A**tomicity)

  > 事务是不可分割的最小操作单元，这个操作单元要么全部成功，要么全部失败。

- 一致性(**C**onsistency)

  > 事务完成的时候，必须使所有数据都保持一致状态。

- 隔离性(**I**solation)

  > 在并发的时候，A事务在操作的时候，它不会影响B事务的执行；B事务在操作的时候，也不会影响A事务。

- 持久性(**D**urability)

  > 事务不管是提交还是回滚，它对数据库里面数据的改变，都是永久的。

### 15.3并发事务引发的问题

- 胀读

  > 一个事务读取到了另外一个事务还没有提交的数据

- 不可重复读

  > 一个事务先后读取同一条记录，但两次读取到的数据不同。因为有其他事务在这个事务还没结束之前提交了一条数据
  >
  > 事务a	500.....500
  >
  > 事务b	-100 commit

- 幻读

  > 一个事务查询某一条记录的时候，没有对应的记录，但是在插入记录的时候，又发现这条记录已经存在了，就好像出现了幻觉一样
  >
  > 事务a：select id=9 -> null insert id=9 -> error select id=9 -> null
  >
  > 事务b：insert id=9 commit

### 15.4 事务的隔离级别

| 隔离级别   | Read Uncommitted | Read Committed | Repeatable Read（默认） | Serializable |
| ---------- | :--------------: | :------------: | :---------------------: | :----------: |
| 脏读       |        ✔︎         |       ✗        |            ✗            |      ✗       |
| 不可重复读 |        ✔︎         |       ✔︎        |            ✗            |      ✗       |
| 幻读       |        ✔︎         |       ✔︎        |            ✔︎            |      ✗       |

问：我们在一个事务里面插入一批非常大的数据，这个事务已经执行了很长时间，并且还在执行过程中，没有提交，如何知道当前已经插入了多少条数据？

答：利用Read Uncommitted隔离级别，用一个新的事务，读取到这一批大数据的插入进度。

```sql
-- 查询事务隔离级别
select @@transaction_isolation

-- 设置事务隔离级别
set {session|global} transaction isolation level <隔离级别>; -- 设置当前会话/全局的隔离级别
```

# 进阶篇

## 1.MySQL体系结构图

![image-20250302161036848](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250302161036848.png)

## 2.Innodb存储结构

![image-20250302161322341](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250302161322341.png)

## 3.索引

### 3.1索引概述

> 索引是一种有序的数据结构，它可以帮助Mysql高效获取数据
>
> 二叉树，B-Tree，红黑树，B+Tree.......
>
> ~~增删改，索引节点与需要同步增删改，不需要考虑，业务系统大部分都是查~~

- **B+Tree索引**
- Hash索引
- FULL-Text索引
- R-Tree索引

|   索引    |   Innodb    | MyIsam | Memory |
| :-------: | :---------: | :----: | :----: |
|  B+Tree   |      ✔      |   ✔    |   ✔︎    |
|   Hash    |      ✗      |   ✗    |   ✔    |
| Full-Text | 5.6之后支持 |   ✔    |   ✗    |
|  R-Tree   |      ✗      |   ✔    |   ✗    |

- 二叉树

  > 顺序插入时，会形成链表，查询效率会大幅度降低
  >
  > 数据结构可视化网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

![image-20250316170429022](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316170429022.png)

- 红黑树

  > 当数据量特别大的时候，层级非常深，查找速度同样会很慢

![image-20250316170501398](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316170501398.png)

- B-Tree树（多路平衡查找树）

  > 示例数据：30,45,52,48,16,69,80,71,12,18,25,94,96,91,115,99,110

![image-20250316170739355](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316170739355.png)

- B+Tree树

  > 所有数据都会出现在叶子节点，叶子节点会形成一个单向链表

![image-20250316171229339](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316171229339.png)

- Hash索引

  > Memory支持
  >
  > Innodb里面也有一个自适应Hash功能，它会更具我们的查询条件，在特定情况下，自动根据B+Tree索引构建Hash索引

![image-20250316172051694](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316172051694.png)

- Innodb索引结构

  > 叶子节点使用双向链表，便于排序和范围查找。
  >
  > B+Tree非叶子节点不存数据，一页能存的指针和key就会更多，每个节点存的指针和key多了，相同数据量的情况下，B+Tree的高度肯定要比B-Tree更低，树的高度低了，查询次数就少了，磁盘io自然也少了

![image-20250316172240955](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250316172240955.png)

在Innodb里面，高度为2的B+Tree，以及高度为3的B+Tree，分别能存多少行数据？假设一行数据大小是1k

```
一页大小：16k，16行
指针：6字节
key：int，4字节
key数量：n，类型int
4n+6n+6=16*1024		10n+6=16384		10n=16378		n=1637.8
key:1637	指针：1638
高度为2：1638*16=26000条
高度为3：1638*1638*16=4200万条
```

### 3.2索引分类

- 主键索引
- 唯一索引
- 常规索引
- 全文索引

存储形式不同：

- 聚集索引（聚簇索引）
- 二级索引（辅助索引、非聚集索引）

> 如果存在主键，主键索引就是聚集索引；
>
> 如果不存在主键，第一个唯一字段，将会被作为聚集索引；
>
> 如果没有主键，也没有唯一字段，Innodb会自动生成一个rowid，作为隐藏的聚集索引

| **特性**         | **聚集索引 (Clustered Index)**       | **二级索引 (Secondary Index)**     |
| :--------------- | :----------------------------------- | :--------------------------------- |
| **数据存储方式** | 索引的叶子节点直接存储**完整数据行** | 叶子节点存储**主键值（或行指针）** |
| **索引数量**     | 每个表**只能有一个**聚集索引         | 每个表可以有**多个**二级索引       |
| **查询效率**     | 主键查询极快（直接定位数据）         | 需要两次查找（先查索引，再查数据） |
| **物理顺序**     | 数据按索引顺序物理存储               | 不影响数据物理存储顺序             |
| **依赖关系**     | 表数据与索引绑定，删除后数据需重建   | 独立于数据，删除不影响表数据       |

![image-20250318223120733](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250318223120733.png)

### 3.3索引语法

- 创建索引

> create {unique|fulltext} index 索引名称 on 表名(字段名称...);

- 查询索引

> show index from 表名;

- 删除所索引

> drop index 索引名称 on 表名;

```sql
create database db1 charset utf8mb4;
use db1;

create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    phone varchar(11) not null,
    email varchar(50),
    age int not null,
    salary float(10, 2),
    post varchar(16),
    join_date date,
    leader_id int
);


insert into emp
values (1, '刘备', 'male', '13035445001', 'abcdabcdeabc@qq.com', 32, 4000, '总经理', '2035-06-01', null),

       (2, '关羽', 'male', '13035445002', 'abcdabcdeghefg@qq.com', 20, 8000, '技术总监', '2035-06-05', 1),
       (3, '张飞', 'male', '13035445003', 'ijklijklijk@qq.com', 25, 12000, '项目经理', '2035-06-10', 2),
       (4, '赵云', 'male', '13035445004', 'abmnoepmnopmno@qq.com', 19, 6800, '产品经理', '2035-06-10', 2),
       (5, '马超', 'male', '13035445005', 'abqrstqrstqrs@qq.com', 26, 11000, '后端开发', '2035-07-11', 2),
       (6, '黄忠', 'female', '13035445006', 'abuvwxuvwxuvw@qq.com', 48, 15000, '后端开发', '2035-07-22', 2),
       (7, '夏侯惇', 'male', '13035445007', 'yzabyzabyza@qq.com', 36, 34000, '后端开发', '2035-07-29', 2),
       (8, '典韦', 'male', '13035445008', 'cdefcdefcdef@qq.com', 19, 6800, '后端开发', '2035-08-02', 2),
       (9, '吕布', 'female', '13035445009', 'ghijghijghij@qq.com', 20, 9000, '前端开发', '2035-08-03', 2),
       (10, '周瑜', 'female', '13035445010', 'klmnklmnklmn@qq.com', 32, 36000, '前端开发', '2035-08-08', 2),
       (11, '文丑', 'male', '13035445011', 'opqropqropqr@qq.com', 27, 24000, '测试', '2035-08-12', 2),

       (12, '诸葛亮', 'male', '13035445012', 'stuevstuvstuv@qq.com', 27, 8000, '市场总监', '2035-06-05', 1),
       (13, '庞统', 'male', '13035445013', 'wxyezwxyzwxy@qq.com', 37, 4200, '销售', '2035-06-06', 12),
       (14, '徐庶', 'male', '13035445014', 'xabcdefghijk@qq.com', 36, 4000, '销售', '2035-06-12', 12),
       (15, '荀彧', 'male', '13035445015', 'lmnopqrstuv@qq.com', 25, 2400, '销售', '2035-06-10', 12),
       (16, '荀攸', 'male', '13035445016', 'wxyszabcdefg@qq.com', 25, 2400, '销售', '2035-06-12', 12),
       (17, '鲁肃', 'male', '13035445017', 'hijklmnopqr@qq.com', 43, 4300, '销售', '2035-06-18', 12),
       (18, '司马懿', 'female', '13035445018', 'stuvwxyzabc@qq.com', 44, 5000, '销售', '2035-06-20', 12),
       (19, '杨修', 'male', '13035445019', 'defghijklmn@qq.com', 19, 800, '销售', '2035-07-10', 12),
       (20, '丁仪', 'male', '13035445020', 'opqsrstuvwxy@qq.com', 49, 3500, '销售', '2035-07-11', 12),

       (21, '宋江', 'male', '13035445021', 'zabcdefghijkl@qq.com', 30, 8000, '人事总监', '2035-06-05', 1),
       (22, '吴用', 'male', '13035445022', 'mnopqrstuvwxyz@qq.com', 38, 3000, '人事主管', '2035-06-06', 21),
       (23, '扈三娘', 'female', '13035445023', 'sabcdefghijklm@qq.com', 42, 2500, '招聘专员', '2035-06-11', 21),
       (24, '顾大嫂', 'female', '13035445024', 'fnopqrstuvwxyz@qq.com', 38, 3300, '招聘专员', '2035-06-25', 21),
       (25, '孙二娘', 'female', '13035445025', 'wabcdefghijklf@qq.com', 32, 2400, '绩效专员', '2035-07-22', 21),
       (26, '丁得孙', 'male', '13035445026', 'enopqrstuvwxyz@qq.com', 32, 2800, '培训专员', '2035-08-10', 21),


       (27, '柴进', 'male', '13035445027', 'tabcdefghijkli@qq.com', 30, 8000, '财务总监', '2035-06-05', 1),
       (28, '卢俊义', 'male', '13035445028', 'inopqrstuvwxyz@qq.com', 44, 4000, '会计', '2035-08-19', 27),
       (29, '晁盖', 'male', '13035445029', 'oabcdefghijkle@qq.com', 44, 3500, '出纳', '2035-08-20', 27),

       (30, '貂蝉', 'female', '13035445030', 'wnopqrstuvwxyz@qq.com', 36, 800, null, '2035-09-01', null);
```

```sql
# 全文索引测试
create table articles(content varchar(5000));
insert into articles values
('这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。'),
('这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子往回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。'),
('Life is too short to spend time with people who suck the happiness out of you. If someone wants you in their life, they’ll make room for you. You shouldn’t have to fight for a spot. Never, ever insist yourself to someone who continuously overlooks your worth. And remember, it’s not the people that stand by your side when you’re at your best, but the ones who stand beside you when you’re at your worst that are your true friends.');

# 创建全文索引，并指定解析器：ngram，MySQL5.7.6以后内置了ngram解析器，支持中文全文索引
create fulltext index idx_articles_content on articles(content) with parser ngram;

# 用全文索引查询，语法条件：match(字段名) against('关键词')
select * from articles where match(content) against('月亮');

# 创建表的时候创建全文索引
create table articles(
    content varchar(5000),
    fulltext (content) with parser ngram
);
```

### 3.4SQL性能分析

- 查询SQL查询频次

  ```sql
  show session status like 'com_insert'; -- 查询当前会话的插入频次
  show global status like 'com_insert'; -- 查询全局的插入频次
  show global status like 'com_delete'; -- 查询全局的删除频次
  show global status like 'com_update'; -- 查询全局的修改频次
  show global status like 'com_select'; -- 查询全局的查询频次
  
  show global status like 'com_______';
  
  show global status where Variable_name rlike 'com_[idus][enp].{4}$'; -- 查询增删改查的频次
  ```

- 慢查询日志

  ```sql
  -- 查询状态
  show variables like 'slow%'; -- 查询以slow开头的系统变量
  select @@slow_query_log; -- 慢查询日志是否开启
  select @@long_query_time; -- 慢查询日志的时间阈值
  select @@slow_query_log_file; -- 慢查询日志文件
  
  -- 设置状态（重启后失效）
  set @@global.slow_query_log=1;
  set @@global.long_query_time=2;
  -- 重启有效
  vi /etc/my.cnf
  [mysqld]
  slow_query_log=1
  long_query_time=2
  ```


- profile

  ```sql
  select @@have_profiling; -- 查看是否支持profiling
  select @@profiling; -- 查看是否打开profiling
  set profiling = 1; -- 打开profiling
  
  
  show profiles;	-- 查询最近的sql执行耗时情况
  show profiles for query <query_id>;		-- 查询某一条sql的耗时具体情况
  show profiles cpu for query <query_id>;		-- 查询某一条sql的耗时具体情况以及cpu情况
  ```

  

- explain

  ```sql
  explain/desc <select语句>; -- 在查询语句前加上explain或desc，可查看查询性能。一般用explain。desc底层也是explain，效率要比explain低
  
  '''
  type:访问类型
  性能从差到好为:all<index<range<index_merge<ref<eq_ref<const<system<NULL
  '''
  
  ```

  

### 3.5索引失效情况

- 最左前缀法制（**联合索引**）

  > 最左列必须存在，并且不跳过索引的中间的列，如果跳过了联合索引中的某一列，后面的字段将会失效
  >
  > 如果出现了范围查询，范围查询右侧的索引将会失效

- 运算操作

- 前面模糊匹配

- 字符串不加引号

- or两侧用到的列有一侧没有索引则整个索引都会失效

- 数据分布影响

### 3.6SQL提示

- use index() 建议mysql使用哪个索引，但是mysql可能不接受

  ```sql
  select * from emp use index(idx_emp_age) where age =25;
  ```

- ignore index() 不要用哪个索引

  ```sql
  select * from emp ignore index(idx_emp_age) where age =25;
  ```

- force index() 强制mysql必须用哪个索引

  ```sql
  select * from emp force index(idx_emp_age) where age =25;
  ```

### 3.7覆盖索引

> 查询的时候使用了索引，而且需要返回的列在该索引里面已经能全部找到

```sql
explain select * from emp where age=25 and salary=2400 and post='销售';
explain select id, name, age from emp where age=25 and salary=2400 and post='销售';
explain select id, salary, post from emp where age=25 and salary=2400 and post='销售';
explain select id, age, salary, post from emp where age=25 and salary=2400 and post='销售';
```

### 3.8前缀索引

> create index 索引名 on 表名(字段名(n));

选择性：不重复的索引值，和总记录数的比值。选择性越接近1越好

```sql
select count(distinct substring(email,1,10))/count(*) from emp; -- 截取前十个字符计算选择性
create index idx_emp_email_4 on emp(email(4)); -- 使用email的前四个字符创建索引
```

### 3.9索引的选择

> 如果频繁出现了多个查询条件，就要考虑给这些查询字段，创建联合索引，而不是单列索引

### 总结

- 对于数据量较大（100万），并且查询比较频繁的表，我们就应该为它创建索引
- 一般都是选择查询条件、排序条件、或者分组条件用到的字段来创建索引
- 选择字段的时候，要尽量选择区分度较高的列作为索引，也就是尽量建立唯一索引，因为区分度越高，索引的效率越高
- 尽量创建联合索引，联合索引很多场景下可以覆盖索引，效率更高，要注意字段顺序
- 字符串较长，可以建立前缀索引，以此来降低索引的体积，减少磁盘io，提高效率
- 索引的数量并不是越多越好，索引越多，确实能够更好的提升查询效率，但同时也意味着，增删改的时候，效率会更加的低，因为每一次增删改，都需要维护索引
- 如果一个字段不能为null，我们就应该加上not null约束，有了这个约束之后，优化器可以更精确地估计查询条件的过滤效果，并且制定更准确的查询执行计划，更快地返回结果

## 4.SQL优化

### 4.1insert优化

- 批量插入

  ```sql
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  ```

  

- 手动插入事务

  ```sql
  begin;
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  commit;
  ```

- 大批量数据插入

  ```sql
  mysql --local-infile -uroot -p
  set global local_infile=1;
  
  # mysql5.7直接用，8.0需要前面两步
  load data local infile '文件路径' into table 表名 fields terminated by '字段分隔符' lines terminated by '换行符';
  ```

- 主键顺序插入

  > 顺序插入的性能，要比乱序插入更高

### 4.2主键优化

- 数据的组织方式

  > 根据主键顺序存放

  ![image-20250405165248933](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250405165248933.png)

- 页分裂
- 页合并
- 主键的设计原则
  - 插入数据的时候，要尽量顺序插入，最好给主键设置自增
  - 尽量不要使用太复杂的值作为主键，比如：uuid，各种证件号码
  - 尽量降低主键的长度
  - 尽量不要修改主键

### 4.3group by 优化

> 单列索引或联合索引都有效
>
> 联合索引需要遵循最左前缀法则

```sql
show index from emp;
create index idx_emp_post_salary_age on emp(post, salary, age);

select post, count(*) from emp group by post;
select post, salary, count(*) from emp group by post, salary;
select post, salary, count(*) from emp where post='销售' group by salary;
explain select post, salary, count(*) from emp where post='销售' group by salary;
```

### 4.4order by 优化

- Using index

  > 通过有序索引顺序扫描，直接返回有序的数据，不需要额外的排序，效率比较高

- Using filesort

  > 通过索引或者全表扫描，读取满足条件的记录，然后在排序缓冲区里面完成排序操作，只要不是通过索引直接返回排序结果的排序，都是filesort

- 联合索引结构

![image-20250405172538479](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250405172538479.png)

![image-20250405172544315](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250405172544315.png)

总结：

- 尽量使用覆盖索引

- 对于多字段排序，需要遵循最左前缀法则

- 如果需要一个升序，一个降序，要在创建联合索引的时候，指定号排序规则（8.0后支持）

- MySQL缓冲区大小默认是256k，如果是大数据量要进行filesort，可以根据实际情况，适当增大排序缓冲区

  ```sql
  select @@sort_buffer_size; -- 查询排序缓存大小
  ```


### 4.5limit优化

> 覆盖索引+子查询
>
> ```sql
> select d.* from test_data d left join (select id from test_data limit 40000000,10) t on d.id=t.id;
> ```

### 4.6.count优化

- count(*)

  > 和count(数字)差不多，不取值，直接累加，同时Innodb对它还做了优化

- count(数字)

  > Innodb会遍历整张表，不取值，只要遍历到一行记录，就会用一个数字作为这行记录的值，然后直接计数累加

- count(主键)

  > Innodb会遍历整张表，把每一行的主键都取出来，取出一个主键，计数就+1

- count(字段名称)

  > 判断当前字段是否有not null约束
  >
  > 如果没有，Innodb会遍历整张表，把每一行的字段值都取出来，然后判断是否为null，不为null，则计数累加
  >
  > 如果有，Innodb会遍历整张表，把每一行的字段值都取出来，直接计数累加

### 4.7update优化

> 要根据有索引的字段进行更新，不然就会出现行锁升级为表锁，Innodb的行锁是针对索引加的锁，不是针对记录加的锁，而且这个索引不能失效，如果索引失效，行锁同样会升级为表锁

## 5.视图

> 视图是一种虚拟存在的表，它只保存SQL逻辑，不保存查询结果
>
> create [or replace] view 视图名[(字段名...)] as select语句 [with [cascaded | local]check option];

```sql
-- 创建视图
create view emp_v1 as select id,name,age from emp where id<=5;

-- 查询视图
select * from emp_v1 where id<=5;

-- 修改视图
create or replace view emp_v1 as select id,name,age from emp where id<=10; -- 用create修改视图时，后面必须加上or replace
alter view emp_v1 as select id,name,age,post from emp where id<=10;

-- 删除视图
drop view if exists emp_v1; -- 也是可以加if exists判断是否存在
```

- cascaded

  > 级联检查依赖的视图

  ```sql
  create table dep(
  	id int primary key auto_increment,
      name varchar(16),
      notes varchar(64)
  );
  insert into dep(name) values
  ('总经办'),('技术部'),('市场部'),('人事部'),('财务部'),('后勤部');
  
  create or replace view dep_v1 as select id,name from dep where id<=10 with cascaded check option ; -- cascaded参数是用来检查操作视图记录是否满足视图条件的
  
  select * from dep_v1;
  
  insert into dep_v1 values(7,'运营部'); -- 插入的数据其实是在基表，视图只是显示
  insert into dep_v1 values(20,'公关部'); -- 由于视图加了with cascaded check option参数，所以这条数据插入时会检查视图where id<=10的条件，不满足时是不会插入到基表的
  
  create or replace view dep_v1 as select id,name from dep where id<=10 ;
  create or replace view dep_v2 as select id,name from dep_v1 where id>=5 with cascaded check option ; -- 视图也可基于视图创建
  insert into dep_v2 values(20,'公关部'); -- 由于视图加了with cascaded check option参数，所以这条数据插入时不仅检查当前视图where id>=5的条件，还会检查该视图基于的视图where id<=10的条件
  insert into dep_v2 values(8,'公关部');
  ```

  

- local

  > 只检查当前视图

  ```sql
  create or replace view dep_v1 as select id,name from dep where id<=10 ;
  create or replace view dep_v3 as select id,name from dep_v1 where id>=5 with local check option ;
  insert into dep_v3 values(20,'公关部');-- 由于视图加了with local check option参数，所以这条数据插入时会检查当前视图where id>=5的条件，但不会检查该视图基于的视图where id<=10的条件。但如果基于的视图也有cascaded或local条件，则还是会根据其对于的条件进行检查
  ```


- 视图更新条件

  > 视图中的行，与基表中的行，必须存在一对一关系
  >
  > 如果出现以下情况，视图将不可更新

  1. 聚合函数或者窗口函数
  2. 出现了distinct
  3. group by
  4. having
  5. union

视图作用

- 简化操作
- 安全
- 屏蔽基表结果变化的影响

```sql
create table music(
    id int primary key auto_increment,
    name varchar(16)
);
insert into music(name) values
('以父之名'),('夜的第七章'),('止战之殇'),('夜曲'),('罗刹海市'),('北京欢迎你');

create table singer(
    id int primary key auto_increment,
    name varchar(16)
);
insert into singer(name) values
('周杰伦'), ('刀郎'), ('刘欢'), ('韩红'), ('成龙');

create table singer2music(
    id int primary key auto_increment,
    music_id int,
    singer_id int
);
insert into singer2music(music_id, singer_id) values
(1, 1),(2, 1),(3, 1),(4, 1),(5, 2),(6, 3),(6, 4),(6, 5);


select music.id, music.name, singer.name from music, singer, singer2music where music.id=singer2music.music_id and singer.id=singer2music.singer_id;


create or replace view sm as select music.id, music.name, singer.name s_name from music, singer, singer2music where music.id=singer2music.music_id and singer.id=singer2music.singer_id;

select * from sm;
```

## 6.窗口函数

> MySQL8.0
>
> over

```sql
select post, count(*) from emp group by post;
select post, sum(salary) from emp group by post;
select id, name, post, count(*) over(partition by post) 岗位人数 from emp;
select id, name, post, sum(salary) over(partition by post) 岗位总薪资 from emp;
select id, name, post, salary, sum(salary) over(partition by post order by salary, id) 岗位总薪资 from emp;
select id, name, post, salary, sum(salary) over(order by salary, id) 总薪资 from emp;
select id, name, post, salary, avg(salary) over(order by id) 历史平均股价 from emp;

-- 窗口函数
select id, name, post, salary, first_value(salary) over(partition by post order by salary, id) first from emp;
select id, name, post, salary, last_value(salary) over(partition by post order by salary, id) last from emp;
select id,
       name,
       post,
       salary,
       first_value(salary) over (partition by post order by salary, id) first,
       last_value(salary) over (partition by post order by salary, id)  last
from emp;

select id, name, post, salary, lead(salary) over(order by id) 下一条数据 from emp;
select id, name, post, salary, lag(salary) over(order by id) 上一条数据, salary-lag(salary) over(order by id) 差值 from emp;

select id, name, post, salary, rank() over(order by id) 序号 from emp;
select id, name, post, salary, rank() over(order by salary) 序号 from emp;
select id, name, post, salary, rank() over(order by salary, id) 序号 from emp;
select id, name, post, salary, dense_rank() over(order by salary) 序号 from emp;
select id, name, post, salary, row_number() over(order by salary) 序号 from emp;

-- 查询每个岗位薪资最高的员工信息
select post, max(salary) from emp group by post;
select * from emp where (post, salary) in (select post, max(salary) from emp group by post);

select *, rank() over(partition by post order by salary desc) n from emp;
select *
from (select *, rank() over (partition by post order by salary desc) n from emp) e1
where n = 1
order by id;
```

## 7.存储过程

> 经过编译，并存储在数据库中的一段SQL集合

```sql
-- 创建存储过程
create procedure 存储过程名字([参数...])
begin 
	sql语句
end;
-- 调用
call 存储过程名称([参数]);

-- eg:
-- 创建存储过程
create procedure p1()
begin
    select * from dep;
end;

-- 在命令行中创建存储过程时，会认为第一个分号就结束了，所以需要在创建之前修改结束符号，创建完成后再修改为分号。
delimiter $$
create procedure p1()
begin
    select * from dep;
end$$
delimiter ;

-- 调用存储过程
call p1();

-- 查看存储过程
select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'db1';

-- 查看存储过程的创建语法
show create procedure p1;

-- 删除存储过程
drop procedure if exists p1;
```

### 7.1 变量

- 系统变量

  > global,session

  ```sql
  -- 查看系统变量
  select @@[global|session] 系统变量名;	-- 查看指定系统变量
  show [global|session] variables;		-- 查看所有系统比变量
  show [global|session] variables like '....';	-- 模糊匹配
  
  -- 设置系统变量
  set @@[global.|session.]系统变量名=值;
  set [global|session] 系统变量名=值;
  
  -- 注意：
  -- global级别的变量，会在MySQL服务端重启后，恢复成初始值，如果想让全局变量重启之后不失效，可以在配置文件里面定义
  ```

- 用户自定义变量

  ```sql
  -- 定义
  set @变量名=值[, .....];
  set @变量名:=值[, .....];
  select @变量名:=值[, .....];
  select 字段名 into @变量名 from 表名 where条件;
  
  -- 查询
  select @变量名[, ....];
  
  -- mysql内变量可不声明直接使用，默认值为null
  -- 销毁(把变量设置为null)
  select @变量名:=null;
  ```

- 局部变量

  ```sql
  -- 局部变量：存储过程内部定义的变量，可以在存储过程内部使用，或者作为存储过程的输入参数
  declare 变量名 变量类型 [default 默认值]; -- 声明存储变量的sql必须写在存储过程的最前面也就是紧跟在begin之后
  ```

  

### 7.2条件判断

```sql
delimiter ;
drop procedure if exists p1;
create procedure p1()
begin
    declare gender varchar(16) default 'male';
    declare res varchar(16);
    set res=if(gender='male','小哥哥','小姐姐');
    select res;
end;

call p1();



delimiter ;
drop procedure if exists p1;
create procedure p1()
begin
    declare score int default 70;
    declare res varchar(16);
    if score >= 90 then
        set res = '优秀';
    elseif score >= 80 then
        set res = '良好';
    elseif score >= 60 then
        set res = '及格';
    else
        set res = '不及格';
    end if;
    select res;
end;

call p1();



delimiter ;
drop procedure if exists p1;
create procedure p1()
begin
    declare score int default 70;
    declare res varchar(16);
    case
    when score >= 90 then
        set res = '优秀';
    when score >= 80 then
        set res = '良好';
    when score >= 60 then
        set res = '及格';
    else
        set res = '不及格';
    end case;
    select res;
end;

call p1();




delimiter ;
drop procedure if exists p1;
create procedure p1()
begin
    declare score int default 70;
    declare res varchar(16);
    set res = case
    when score >= 90 then '优秀'
    when score >= 80 then '良好'
    when score >= 60 then '及格'
    else '不及格'
    end;
    select res;
end;

call p1();


```

### 7.3参数

- in(默认)：输入参数，定义时如果不写类型默认是输入类型
- out：输出参数
- inout：输入输出参数，既可做输入也可做输出

```sql
create procedure 存储过程名字([in/out/inout 参数名 参数类型, ....])
begin 
	sql语句
end;

-- in、out举例
delimiter ;
drop procedure if exists p1;
create procedure p1(in score int,out res varchar(16))
begin
    set res = case
        when score >= 90 then '优秀'
        when score >= 80 then '良好'
        when score >= 60 then '及格'
        else '不及格'
    end;
end;

call p1(88, @res); -- 定义的输出参数也要传，未赋值默认为null
select @res

-- inout举例
delimiter ;
drop procedure if exists p1;
create procedure p1(inout score double)
begin
    set score = score/10;
end;

set @score = 88;
call p1(@score);
select @score;
```

### 7.4循环语句

- while循环

  > while 条件 do
  >
  > ​	sql逻辑

  ```sql
  -- while循环，先判断条件，满足条件就执行，不满足就跳出循环
  create procedure p2(in num int)
  begin
      declare res int default 0;
      while num>0 do
          set res = res + num;
          set num = num - 1;
          end while;
      select res;
  end;
  
  call p2(100);
  ```

  

- repeat循环

  > repeat
  >
  > ​	sql逻辑
  >
  > until 条件
  >
  > end repeat;

  ```sql
  -- repeat循环,先执行一遍，再判断条件是否满足，满足就跳出循环，不满足就继续执行
  create procedure p3(in num int)
  begin
      declare res int default 0;
      repeat
          set res = res + num;
          set num = num - 1;
      until num <= 0
      end repeat;
      select res;
  end;
  
  call p3(100);
  ```

  

- loop循环

  > [标签:]loop
  >
  > ​	sql逻辑;
  >
  > leave 标签;
  >
  > iterate 标签;
  >
  > end loop [标签];

  ```sql
  -- leave表示结束循环；iterate表示跳出本次循环
  create procedure p4(in num int)
  begin
      declare res int default 0;
      sum:loop
          if num = 5 then
              set num = num -1;
              iterate sum;
          end if;
  
          set res = res + num;
          set num = num - 1;
          if num <= 0 then
              leave sum;
          end if;
      end loop;
      select res;
  end;
  
  call p4(100);
  ```

### 7.5游标

> 他是一种用来存储查询结果集的数据类型。（相当于把文件读取出来放在一个可迭代对象里面用fetch一行一行去读）

- 声明游标

  > declare 游标名称 cursor for select语句;

- 打开游标

  > open 游标名称;

- 读取游标记录

  > fetch 游标名称 into 变量名[,...];

- 关闭游标

  > close 游标名称;

```sql
-- 用户传入一个参数u_salary,查询emp表里面所以薪资小于该参数的员工姓名，年龄薪资，岗位
-- 然后存储到一张新表里面
drop procedure if exists p5;
create procedure p5(in u_salary int)
begin
    declare my_name varchar(16);
    declare my_age int;
    declare my_salary float(10,2);
    declare my_post varchar(16);
    declare my_cursor cursor for select name,age,salary,post from emp where salary < u_salary; -- 游标必须在普通参数之后定义
#     declare exit handler for SQLSTATE '02000' close my_cursor; -- handler必须在普通参数之后定义，捕获到02000异常就退出游标
    declare exit handler for NOT FOUND close my_cursor; -- 捕获到02开头的状态码异常就退出游标
    drop table if exists tb_cursor;
    create table tb_cursor(
        id int primary key auto_increment,
        name varchar(16),
        age int,
        salay float(10,2),
        post varchar(16)
    );
    open my_cursor;
    while true do
        fetch my_cursor into my_name,my_age,my_salary,my_post;
        insert into tb_cursor(name, age, salay, post) values(my_name,my_age,my_salary,my_post);
    end while;
    close my_cursor;
end;

call p5(3000);
```



### 7.6条件处理程序(handler)

> declare continue/exit handler for 条件 SQL逻辑;

```sql
SQLSTATE 状态码 -- 捕获某一个状态码
SQLWARNING     -- 警告信息，所有01开头的状态码
NOT FOUND      -- 没有找到数据，所以02开头的状态码
SQLEXCEPTION   -- SQLWARNING、NOT FOUND捕获不到的，都可以捕获
```



## 8.存储函数

> 存储函数有返回值的存储过程，存储函数的参数只能是in类型

```sql
create function 存储函数名字([参数,...])
returns 返回值类型 [特性参数]
begin 
	sql逻辑;
	return 返回值;
end;

'''
特性参数（MySQL8.0之后必写参数）：
1. DETERMINISTIC：指定函数是确定性的。这意味着对于给定的输入参数，函数的返回值总是相同的。这个参数可以帮助优化器进行性能优化，因为它允许缓存函数的结果。
2. NOT DETERMINISTIC：指定函数是非确定性的。这意味着对于给定的输入参数，函数的返回值可能会发生变化。这个参数适用于那些可能会根据外部因素（如当前时间）变化的函数。
3. READS SQL DATA：指定函数会读取数据，包括表、视图等。也就是说，函数在执行过程中会对数据库进行读取操作。
4. MODIFIES SQL DATA：指定函数会修改数据，比如插入、更新或删除表中的数据。函数在执行过程中会对数据库进行写入操作。
5. NO SQL：指定函数既不读取也不修改数据库中的数据。这意味着函数在执行过程中不会对数据库进行读写操作。

这些特性参数用于提供函数的特性，可以帮助优化器更好地进行性能优化。
'''

-- 创建存储函数
create function f1(num int)
returns int DETERMINISTIC
begin
    declare res int;
    select count(*) into res from emp where salary < num;
    return res;
end;

-- 调用存储函数
set @num = f1(5000);
select @num;

select f1(5000);
```

## 9.触发器

> 它是一个和表有关的数据库对象，可以在插入、更新、以及删除数据之前或者之后触发，触发器触发之后，就会执行触发器里面定义的SQL逻辑

```sql
create trigger 触发器名称
before/after insert/update/delete on 表名 for each row
begin
	sql逻辑
end;

-- eg:记录emp的数据变更日志，并把变更日志插入到日志表emp_logs里面
create table emp_logs(
    id int primary key auto_increment,
    event_type varchar(16) not null ,
    event_time datetime not null ,
    event_id int not null ,
    event_content varchar(800)
);

-- 插入数据的触发器
create trigger emp_insert_tirgger
    before insert on emp for each row
    begin
        insert into emp_logs values(null, 'insert', now(), new.id, concat('插入的数据:', 'id=', new.id, ',name=', new.name, ',gender=', new.gender, ',phone=', new.phone, ',email=', new.email, ',age=', new.age, ',salary=', new.salary, ',post=', new.post, ',join_date=', new.join_date, ',leader_id=', new.leader_id));
    end; -- new方法是记录sql操作之后的数据

show triggers ; -- 查询触发器
drop trigger emp_insert_tirgger; -- 删除触发器

insert into emp values
(32, '小乔', 'female', '13035445031', 'wnopqrstuvwxyz1@qq.com', 19, 800, '会计', '2035-09-02', 27); -- 插入数据时候就会触发触发器里面的sql

select concat(13,'abv',ifnull(null,'2'));-- concat方法拼接时如果有字段为null，拼接后的数据就为null，所以拼接时可以用ifnull判断下

-- 更新数据的触发器
create trigger emp_update_tirgger
    before update on emp for each row
    begin
        insert into emp_logs values(null, 'update', now(), new.id, concat(
                '更新之前的数据:', 'id=', old.id, ',name=', old.name, ',gender=', old.gender, ',phone=', old.phone, ',email=', old.email, ',age=', old.age, ',salary=', old.salary, ',post=', old.post, ',join_date=', old.join_date, ',leader_id=', old.leader_id,
                '更新之后的数据:', 'id=', new.id, ',name=', new.name, ',gender=', new.gender, ',phone=', new.phone, ',email=', new.email, ',age=', new.age, ',salary=', new.salary, ',post=', new.post, ',join_date=', new.join_date, ',leader_id=', new.leader_id
));
    end;-- old方法是记录sql操作之前的数据，new方法是记录sql操作之后的数据

show triggers ;
drop trigger emp_update_insert_tirgger;

update emp set salary= 10000 where id>=31;-- 更新数据时候就会触发触发器里面的sql

delimiter ;
-- 删除数据的触发器
create trigger emp_delete_tirgger
    before delete on emp for each row
    begin
        insert into emp_logs
        values (null, 'delete', now(), old.id, concat(
                '删除的数据:', 'id=', old.id, ',name=', old.name, ',gender=', old.gender, ',phone=', old.phone,
                ',email=', old.email, ',age=', old.age, ',salary=', old.salary, ',post=', old.post, ',join_date=',
                old.join_date, ',leader_id=', old.leader_id));
    end;

show triggers ;

delete from emp where id>=31;-- 删除数据时候就会触发触发器里面的sql

```

## 10.锁

### 10.1全局锁

```sql
-- 加锁
flush tables with read lock;

-- 释放锁
unlock tables;
```

问题：

1.业务全部停止

2.主从结构，读写分离，主从延迟

解决：备份数据时用--single-transaction(快照读)备份，这样备份的时候不用加锁，也就是备份下拍下快照时的数据忽略备份后更新的数据

```sql
# 备份
mysqldump --single-transaction -h <ip> -uroot -p <库名> > <备份文件路径>
```



### 10.2表级锁

- 表锁

  - 表共享读锁（read lock)

    > 所有客户端都只能读取，其他客户端写入操作被阻塞，当前客户端只能读，写入会报错

  - 表独占写锁（write lock）

    > 当前客户端可读可写，其他客户端读写操作都会被阻塞

  语法：

  ```sql
  -- 加锁
  lock tables 表名1 [表名2] write/read; -- 多张表加相同的锁
  lock tables 表名1 write [, 表名2 read]; -- 不同表加不同锁
  
  -- 释放锁
  unlock tables;-- 客户端断开连接也会自动释放锁
  ```

- 元数据锁（meta data lock,简称MDL)

  > 系统控制，在我们访问表的时候，会自动加上，不需要手动操作/为了避免DML和DDL的冲突，当一张表上面存在未提交的事务，其他事务是不能修改元数据的，或者说不能修改表结构

  增删改查：加MDL共享锁

  修改表结构：加MDL排他锁

  | SQL类型                    | MDL锁类型                               | 描述            |
  | -------------------------- | --------------------------------------- | --------------- |
  | select ...                 | SHARED_READ（共享读锁）                 | 兼容            |
  | insert、update、delete     | SHARED_WRITE（共享写锁）                | 兼容            |
  | alter table ...            | EXCLUSIVE（排他锁）                     | 与其它MDL锁互斥 |
  | lock tables ... read/write | SHARED_READ_ONLY / SHARED_NO_READ_WRITE |                 |

  MySQL8.0以前，打开元数据锁设置（8.0之后默认是打开的）：

  ```text
  [mysqld]
  performance-schema-instrument='wait/lock/metadata/sql/mdl=ON'
  ```

  查看元数据锁：`select OBJECT_SCHEMA, LOCK_TYPE from performance_schema.metadata_locks;`
  
- 意向锁

  > 在事务对某条数据操作，并加上行锁时，会同时加上意向锁。这是为了其他事务在操作时候若要加上表锁，则不需要逐一扫描数据行是否有行锁与表锁排斥，而直接扫描是否存在意向锁即可。

  - 意向共享锁(IS)

    > select 语句 lock in share mode; -- 加上行锁的共享锁，并同时加上意向共享锁
    >
    > 兼容表共享读锁，排斥表独占写锁

  - 意向排他锁(IX)

    > insert、delete、update语句、以及select语句for update;
    >
    > 排斥所有表锁、意向锁和意向锁之间兼容

    ```sql
    -- 查看意向锁和行锁的加锁情况
    -- MySQL5.7.14之前(5.7.14被弃用，8.0后被删除)
    select * from information_schema.innodb_locks;
    
    -- 8.0后
    select * from performance_schema.data_locks;
    select OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_DATA 
    from performance_schema.data_locks;
    ```

### 10.3行级锁

> 每次操作锁定对应的行数据，它的粒度是最小的，发生锁冲突的改了也是最低的，所以并发性能也是最高的

![image-20250525203806603](C:\Users\TYF\AppData\Roaming\Typora\typora-user-images\image-20250525203806603.png)

- 行锁（read lock）

  > 锁定单条记录的锁，在RC和RR隔离级别下都是支持的

  - 共享锁/读锁（简写S）：兼容共享锁，不兼容排他锁
  - 排他锁/写锁（简写X）：不兼容共享锁，不兼容排他锁

  | SQL                            | 行锁类型       |
  | ------------------------------ | -------------- |
  | insert ...                     | 排他锁（自动） |
  | delete ...                     | 排他锁（自动） |
  | update ...                     | 排他锁（自动） |
  | select ...                     | 无行锁         |
  | select ... lock in share mode; | 共享锁         |
  | select ... for update;         | 排他锁         |

- 间隙锁（gap lock）

  > 对两条记录之间的间隙加锁，锁定当前记录之前的间隙（不锁记录），加上间隙锁之后，可以确保在当前事务里面被锁住的间隙不变，防止其他事务在这个间隙里面插入数据，从而产生幻读现象，在RR隔离级别下支持，间隙锁之间兼容

- 临键锁（next-key lock）

  > 行锁和间隙锁的组合，同时锁住数据，以及数据前的间隙

在默认的事务隔离级别下，Innodb会使用next-key（临键锁）进行扫描，防止出现幻读：

1. 在唯一索引下，针对已存在的记录进行等值匹配的时候，会自动把这个临键锁优化成行锁。
2. Innodb的行锁是针对索引加的锁，如果不通过索引字段查询，Innodb就会对表中的所有记录加行锁，类似于行锁升级为了表锁
3. 唯一索引上的等值查询，给不存在的记录加锁时，会自动把临键锁优化为间隙锁。
4. 常规索引上的等值查询，向右遍历到第一个不满足查询条件的值，临键锁会自动退化为间隙锁。
5. 对于范围查询（有索引），满足条件的值都回被加上临键锁，对应的主键上会加上行锁（本身是主键除外）。

```sql
-- 查看意向锁和行级锁的加锁情况
select OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_DATA 
from performance_schema.data_locks;
-- 分辨行级锁类型,查看LOCK_MODE
S -- 表示共享临建锁
S,REC_NOT_GAP -- 表示共享行锁
S,GAP -- 表示共享间隙锁
X -- 表示排他临建锁
X,REC_NOT_GAP -- 表示排他行锁
X,GAP -- 表示排他间隙锁
```

### 10.4死锁

> 当两个或两个以上的事务相互等待对方释放资源时，就会发生死锁。发生死锁时mysql会自动释放后面造成死锁的事务
>
> eg：当事务A锁定了行1，事务B锁定了行2，事务A再去锁定行2（形成阻塞但还不构成死锁），事务B再去锁定行1（造成死锁，会被释放回滚）
>
> 事务A	行1	行2（阻塞）
>
> 事务B	行2	行1（阻塞）	回滚

```sql
-- 事务A
begin;
update dep set name = 'A1' where id = 1;
update dep set name = 'A5' where id = 5;


-- 事务B
begin;
update dep set name = 'B5' where id = 5;
update dep set name = 'B1' where id = 1;

-------------------------------------------------------

-- 事务A
begin;
select * from dep where id = 6 for update; -- 会加上排他临建锁
insert into dep values(6, 'A16', 16);

-- 事务B
begin;
select * from dep where id = 7 for update; -- 也会加上排他临建锁，但因为临建锁之间是兼容的
insert into dep values(7, 'B17', 17);

-------------------------------------------------------

-- 事务A
begin;
select * from dep where id = 6 lock in share mode;
insert into dep values(6, 'A16', 16);

-- 事务B
begin;
select * from dep where id = 7 lock in share mode;
insert into dep values(7, 'B17', 17);
```

- 尽量避免长事务，可以考虑把长事务分割为短事务，从而减少锁的持有时间
- 尽量避免一个事务锁定多个资源
- 尽量都按照统一的顺序来请求锁
- 如果允许出现幻读和不可重复读，可以使用RC隔离级别

### 10.5 乐观锁

> 在并发场景下，多个事务可能会访问同一条记录，乐观锁则认为，发生冲突的概率很低，所以在进行业务操作的时候，不会一开始就锁定数据，而是在提交数据更改时，检查当前数据是否有被其他事务修改，如果没有就提交数据，否则就回滚事务。
>
> id	name	版本/时间戳

注：适用于冲突概率较低的场景。如：读多写少的场景，分布式系统（网络延迟）

```sql
-- 事务A
begin;
select * from dep where id=1;
update dep set number=number -10 where id=1 and update_time='2025-05-28 21:16:27'; -- 事务A利用查出来的最后一次的更新时间来修改数据，但这个时候事务B已经更新了数据，所以查到的最新的更新时间并不对，所以没有数据被更新。
rollback; -- 从而回滚事务，重新去执行该事务
-- 事务B
update dep set number=number -10 where id=1 and update_time='2025-05-28 21:16:27'; -- 事务B修改数据时早于事务A
```

### 10.6 悲观锁

> 为了保证数据的完整性和一致性，在事务一开始读取的时候，就先把数据给锁上。

注：适用于冲突较高的场景。如：写多读少的场景，强一致性的业务（银行相关）
